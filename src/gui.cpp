#define RAYLIB_NUKLEAR_IMPLEMENTATION
#include "include/gui.h"
#ifdef ANDROID
	#include "../lib/imgui/imgui.h"
	#include "../lib/imgui/backends/imgui_impl_android.h"
#else
	#include "../lib/imgui/backends/imgui_impl_glfw.h"
	#include "../lib/imgui/backends/imgui_impl_opengl3.h"
#endif
#include "../lib/raylib/src/raylib.h"
#include "../lib/raylib/src/rlgl.h"
#include "include/client.h"
#include "include/main.h"
#include "include/server.h"
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

extern int game_running;
extern Rectangle game[3][3];

#ifdef ANDROID
	#include <android_native_app_glue.h>
	#include <jni.h>
void toggleKeyboard(bool show) {
	// some "aliases"
	JavaVM *lJavaVM = app->activity->vm;
	JNIEnv *lJNIEnv = app->activity->env;

	// java vm args
	JavaVMAttachArgs lJavaVMAttachArgs;
	lJavaVMAttachArgs.version = JNI_VERSION_1_6;
	lJavaVMAttachArgs.name	  = "NativeThread";
	lJavaVMAttachArgs.group	  = NULL;

	// attaching to the java vm
	if ((*lJavaVM).AttachCurrentThread(&lJNIEnv, &lJavaVMAttachArgs) == JNI_ERR) return;

	// get native activity class and the method that we need
	jobject lNativeActivity	   = app->activity->clazz;
	jclass ClassNativeActivity = (*lJNIEnv).GetObjectClass(lNativeActivity);
	// method name depending on the show parameter
	char *lMethodName = NULL;
	if (show)
		lMethodName = (char *)"showKeyboard";
	else
		lMethodName = (char *)"hideKeyboard";
	jmethodID _method = (*lJNIEnv).GetMethodID(ClassNativeActivity, lMethodName, "()V");

	// call that method
	(*lJNIEnv).CallVoidMethod(lNativeActivity, _method);
}
bool getKeyboardState() {
	// some "aliases"
	JavaVM *lJavaVM = app->activity->vm;
	JNIEnv *lJNIEnv = app->activity->env;

	// java vm args
	JavaVMAttachArgs lJavaVMAttachArgs;
	lJavaVMAttachArgs.version = JNI_VERSION_1_6;
	lJavaVMAttachArgs.name	  = "NativeThread";
	lJavaVMAttachArgs.group	  = NULL;

	// attaching to the java vm
	if ((*lJavaVM).AttachCurrentThread(&lJNIEnv, &lJavaVMAttachArgs) == JNI_ERR) return false;

	// get native activity class and the method that we need
	jobject lNativeActivity	   = app->activity->clazz;
	jclass ClassNativeActivity = (*lJNIEnv).GetObjectClass(lNativeActivity);
	// method name depending on the show parameter
	jmethodID _method = (*lJNIEnv).GetMethodID(ClassNativeActivity, "getKeyboardState", "()Z");

	// call that method
	return (*lJNIEnv).CallBooleanMethod(lNativeActivity, _method);
}

float SCR_HEIGHT = 0;
float SCR_WIDTH	 = 0;
#else
float SCR_WIDTH	 = 450;
float SCR_HEIGHT = 800;
#endif
Color BG_COLOR = (Color){45, 45, 45, 255};
Color FG_COLOR = (Color){175, 175, 175, 255};

void initHitBox() { // creating boxes to detect touch or mouse clicks
	for (int i = 0; i < 9; i++) {
		game[i / 3][i % 3].x	  = (BLOCK * (i % 3)) + THICKNESS;
		game[i / 3][i % 3].y	  = (BLOCK * (i / 3)) + THICKNESS;
		game[i / 3][i % 3].height = BLOCK - 1;
		game[i / 3][i % 3].width  = BLOCK - 1;
	}
}

void grid() {
	// Borders
	DrawLineEx((Vector2){0, 1}, (Vector2){SCR_WIDTH, 1}, THICKNESS + 1, FG_COLOR);
	DrawLineEx((Vector2){1, 1}, (Vector2){1, SCR_WIDTH}, THICKNESS + 1, FG_COLOR);
	DrawLineEx((Vector2){0, SCR_WIDTH}, (Vector2){SCR_WIDTH, SCR_WIDTH}, THICKNESS + 1, FG_COLOR);
	DrawLineEx((Vector2){SCR_WIDTH, 0}, (Vector2){SCR_WIDTH, SCR_WIDTH}, THICKNESS + 1, FG_COLOR);

	// vertical grid
	DrawLineEx((Vector2){BLOCK, 0}, (Vector2){BLOCK, SCR_WIDTH}, THICKNESS + 1, FG_COLOR);
	DrawLineEx((Vector2){BLOCK * 2, 0}, (Vector2){BLOCK * 2, SCR_WIDTH}, THICKNESS + 1, FG_COLOR);

	// horizontal grid
	DrawLineEx((Vector2){0, BLOCK}, (Vector2){SCR_WIDTH, BLOCK}, THICKNESS + 1, FG_COLOR);
	DrawLineEx((Vector2){0, BLOCK * 2}, (Vector2){SCR_WIDTH, BLOCK * 2}, THICKNESS + 1, FG_COLOR);
}

// https://github.com/oskaritimperi/imgui-impl-raylib/blob/master/imgui_impl_raylib.cpp
void ImGui_ImplRaylib_Render(ImDrawData *draw_data) {
	auto DrawTriangleVertex = [](ImDrawVert idx_vert) -> void {
		Color *c = (Color *)&idx_vert.col;
		rlColor4ub(c->r, c->g, c->b, c->a);
		rlTexCoord2f(idx_vert.uv.x, idx_vert.uv.y);
		rlVertex2f(idx_vert.pos.x, idx_vert.pos.y);
	};

	rlDisableBackfaceCulling();
	for (int n = 0; n < draw_data->CmdListsCount; n++) {
		const ImDrawList *cmd_list	 = draw_data->CmdLists[n];
		const ImDrawVert *vtx_buffer = cmd_list->VtxBuffer.Data; // vertex buffer generated by Dear ImGui
		const ImDrawIdx *idx_buffer	 = cmd_list->IdxBuffer.Data; // index buffer generated by Dear ImGui
		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++) {
			const ImDrawCmd *pcmd = &(cmd_list->CmdBuffer.Data)[cmd_i]; // cmd_list->CmdBuffer->data[cmd_i];
			if (pcmd->UserCallback) {
				pcmd->UserCallback(cmd_list, pcmd);
			} else {
				ImVec2 pos = draw_data->DisplayPos;
				int rectX  = (int)(pcmd->ClipRect.x - pos.x);
				int rectY  = (int)(pcmd->ClipRect.y - pos.y);
				int rectW  = (int)(pcmd->ClipRect.z - rectX);
				int rectH  = (int)(pcmd->ClipRect.w - rectY);
				BeginScissorMode(rectX, rectY, rectW, rectH);
				{
					unsigned int *ti = (unsigned int *)pcmd->TextureId;
					for (unsigned int i = 0; i <= (pcmd->ElemCount - 3); i += 3) {
						rlPushMatrix();
						rlBegin(RL_TRIANGLES);

						ImDrawIdx index;
						ImDrawVert vertex;

						index  = idx_buffer[i];
						vertex = vtx_buffer[index];
						DrawTriangleVertex(vertex);

						index  = idx_buffer[i + 2];
						vertex = vtx_buffer[index];
						DrawTriangleVertex(vertex);

						index  = idx_buffer[i + 1];
						vertex = vtx_buffer[index];
						DrawTriangleVertex(vertex);
						rlEnd();
						rlPopMatrix();
					}
				}
			}
			idx_buffer += pcmd->ElemCount;
		}
	}
	EndScissorMode();
	rlEnableBackfaceCulling();
}

int join_window(char *IP_ADDRESS, int *PORT, struct client_data *data) {
	int selection_step = 0, game_mode = -1;
	bool game_hosting = false, window_close = false;
	const char *title_label[4] = {"Select game mode", "Select Game Hosting", "Join match", "Host match"};
	const char *btn_label[4]   = {"Single Player", "Multi Player", "Host", "Join"};
	ImVec2 wg_push[2]		   = {{(SCR_WIDTH / 2) - 10, (SCR_HEIGHT / 18)}, {(SCR_WIDTH / 2) - 15, (SCR_HEIGHT / 18)}};
	sprintf(data->username, "Nickname");
	sprintf(IP_ADDRESS, "127.0.0.1:5555");
	*PORT = 5555;
	while (!game_running && !window_close) {
		if (WindowShouldClose()) {
			window_close = true;
			game_mode	 = -1;
		}
		BeginDrawing();
#ifdef ANDROID
		ImGui_ImplAndroid_NewFrame();
#else
		ImGui_ImplOpenGL3_NewFrame();
		ImGui_ImplGlfw_NewFrame();
#endif
		ImGui::NewFrame();
		ClearBackground(RAYWHITE);

		ImGui::SetNextWindowPos(ImVec2(0.0f, 0.0f));
		ImGui::SetNextWindowSize(ImVec2(SCR_WIDTH, SCR_HEIGHT), 1);
		ImGui::Begin("Game mode selection", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse);

		// draw title
		ImGui::SetCursorPos(ImVec2((SCR_WIDTH - ImGui::CalcTextSize("addicted to cocaine").x) / 2, (SCR_HEIGHT / 2) - (SCR_HEIGHT / 9) - 20));
		ImGui::Text("%s", title_label[selection_step + game_hosting]);
		// widget 1
		if (selection_step == 0) { // single player
			if (ImGui::Button(btn_label[selection_step * 2], wg_push[0])) {
				game_running   = 1;
				game_mode	   = 0;
				selection_step = 3;
			}
		} else if (selection_step == 1) { // host a match
			if (ImGui::Button(btn_label[selection_step * 2], wg_push[0])) {
				selection_step++;
				game_hosting = true;
			}
		} else if (selection_step == 2) { // username
			ImGui::InputText("Username", data->username, 32);
			// #ifdef ANDROID
			// if (nkedit_event & NK_EDIT_ACTIVATED)
			// 	toggleKeyboard(true);
			// else if (nkedit_event & NK_EDIT_DEACTIVATED)
			// 	toggleKeyboard(false);
			// #endif
		}						   // widget 2
		if (selection_step == 0) { // multi player
			ImGui::SameLine();
			if (ImGui::Button(btn_label[selection_step * 2 + 1], wg_push[1])) {
				selection_step++;
				game_mode = 1;
			}
		} else if (selection_step == 1) { // join match
			ImGui::SameLine();
			if (ImGui::Button(btn_label[selection_step * 2 + 1], wg_push[1])) {
				selection_step++;
				game_hosting = false;
			}
		} else if (selection_step == 2) {
			ImGui::InputText("IP Address", IP_ADDRESS, 32);
			if (ImGui::Button("Connect"))
				selection_step = 3;
			// #ifdef ANDROID
			// 			if (nkedit_event & NK_EDIT_ACTIVATED)
			// 				toggleKeyboard(true);
			// 			else if (nkedit_event & NK_EDIT_DEACTIVATED)
			// 				toggleKeyboard(false);
			// #endif
		}
		// end selection if multiplayer
		if (selection_step == 3) {
			char *port = strchr(IP_ADDRESS, ':');
			if (port) {
				*PORT	= atoi(port + 1);
				port[0] = '\0';
			}
			game_running = 1;
			game_mode += game_hosting;
		}

		ImGui::End();

		ImGui::Render();
#ifndef ANDROID
		ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
#endif
		EndDrawing();
	}
	return game_mode;
}

void matchInfo(struct client_data *data) { // draw match info
	const char *info_text = TextFormat("It's %s %s turn!", data->turn ? data->users[0] : data->users[1], data->turn ? "(x)" : "(O)");
	DrawText(info_text, (SCR_WIDTH - MeasureText(info_text, STTT_TEXT_SIZE)) / 2, BLOCK * 3 + 10, STTT_TEXT_SIZE, FG_COLOR);
	DrawText(TextFormat("%s: %i\n%s: %i\n", data->users[0], data->winsP[0], data->users[1], data->winsP[1]), 10, BLOCK * 3 + 40, STTT_TEXT_SIZE, FG_COLOR);
	DrawText(TextFormat("%s\n", data->local_ip), 10, SCR_HEIGHT - STTT_TEXT_SIZE * 2, STTT_TEXT_SIZE, FG_COLOR);
}